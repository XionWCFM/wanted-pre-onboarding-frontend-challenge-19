1. DOM과 Virtual DOM을 설명해주세요

DOM이란 문서의 계층적 구조와 정보를 표현하는 모델이자 해당 문서를 조작하는 방법을 제공하는 인터페이스라고 정의할 수 있습니다.

현대 웹 개발 생태계에는 수많은 브라우저가 존재하지만 대부분의 브라우저들은 DOM의 구현에 있어 약속된 표준 규약들을 준수하며 브라우저를 개발하기 때문에 개발자들은 구현이 아닌 DOM이라는 인터페이스에 의존하는 것을 통하여 서로 다른 수많은 브라우저들에 대해 일일히 대응하지 않고도 문서를 조작할 수 있습니다.

그러한 관점에서 저는 DOM이 "인터페이스"라는 것이 가장 재미있는 지점이라고 봅니다. DOM은 마치 JSON 처럼 특정 프로그래밍언어에 구애되지도 않으며 특정 구현에 의존되지도 않습니다. 또한 통상적으로 DOM은 자바스크립트를 이용하여 구현되지만 DOM을 구현하는 방법이 꼭 자바스크립트일 필요도 없습니다. 그렇기 때문에 현대 웹개발에서는 자바스크립트가 아닌 언어로도 DOM을 조작할 수 있으며 여러 브라우저에서도 대체로 동일하게 DOM을 조작할 수 있습니다.

Virtual DOM은 쉽게 생각하면 실제 DOM의 "가상화" 버전이라고 생각할 수 있습니다.

왜 실제 DOM의 가상화 버전을 들고 있어야 하는 것일까요?

이는 SPA를 구현함에 있어서 발생하는 여러가지 성능적 문제를 해결하기 위함입니다. DOM을 조작하여 DOM의 스타일이 변경되거나 새로운 노드가 추가되는 경우 브라우저는 해당 노드의 변경점을 화면에 반영해주어야합니다. 이 과정에서 브라우저는 각 DOM 노드들의 크기와 적절한 레이아웃을 계산해야하며 이 계산 작업은 동기적으로 이루어지게 됩니다.

복잡한 SPA는 DOM을 매우 많이, 자주 조작하게 되곤 하는데요 이러한 SPA의 특성은 자주일어나면 무시못할 부하를 불러오는 DOM 조작을 많이 발생시킬 수 있습니다. 그렇기 때문에 당연히 모든 조작을 한번에 뭉쳐서 화면에 반영하면 좋겠죠? 그렇기 때문에 DOM에서는 Fragment 라고 부르는 API를 제공합니다. 한번에 Fragment로 뭉쳐서 변화를 반영시키면 싸게 바꿀 수 있다는것이지요

VirtualDOM은 DOM 조작을 자주하면 일어나는 성능 문제를 해결함과 더불어 Fragment를 이용하는 낮은 추상화 수준의 방식에서 일어나는 불편함도 함께 해결해줍니다. fragment를 이용하여 수동으로 관리하게되면 어떤 부분이 바뀌었는지, 어떤 부분이 바뀌지 않았는지를 계속 파악해야하는데 이것은 프로젝트가 커지면 굉장히 까다로운 일이 되기 쉬우니까요

그리고 이러한 Virtual DOM은 주로 자바스크립트 생태계에서는 자체적인 구조의 객체로 구현하는 경우가 대부분입니다. React로 예를 들면 React는 Fiber라고 부르는 객체를 정의해두고 Fiber 객체를 통하여 VirtualDOM을 구성합니다.

왜 가상돔을 실제 DOM NODE로 가지고 있지 않는 걸까요?

이 맥락을 이해하기 위해서는 DOM의 구현에 대한 약간의 이해를 필요로 합니다. DOM을 조작하기 위한 API는 굉장히 방대하며 DOM을 이루는 각 노드 객체들은 이 API의 구현들을 지니고 있어야합니다. 자바스크립트로 구현된 DOM의 경우 프로토타입의 상속을 이용하여 구현하는 것이 통상적이기 때문에 터무니없는 메모리 사용은 일어나지 않지만 가지고 있어야하는 노드 객체의 양이 많아질수록 많은 자원을 필요로 하게 됩니다.

정리하면 Virtual DOM이란 SPA에서 쉽게 발생할 수 있는 성능 문제를 해결함과 동시에 사용자가 "선언적"으로 DOM을 관리할 수 있는 토대를 제공하는 개념이라고 할 수 있습니다.

그러나 이러한 Virtual DOM은 결국 프로젝트가 커질수록 해당 프로젝트의 돔트리의 구조를 그대로 지녀야하는 특성상 선형적으로 무거워진다는 한계가 존재합니다. 리액트가 만들어지던 시기에는 "충분히 빠르다"는 논리하에 Virtual DOM을 채택하였지만 개인적으로는 Quik, Solid, Svelte 등 더 좋은 답을 내놓은 프레임워크들이 많다고 생각이 됩니다.

2. 리액트의 특징을 설명해주세요.

리액트의 가장 큰 특징은 라이브러리라는 점을 들 수 있을 듯 합니다.

UI라는 관심사에 대한 라이브러리이기 때문에 통상적인 기능을 지닌 SPA 개발을 리액트로 수행하기 위해서는 여러가지 서드파티라이브러리들이 요구되곤 하기 떄문입니다.

구현적인 관점에서 본다면 Virtual DOM을 채택한 점과 그 Virtual DOM을 총 두벌로 관리하는 더블버퍼링 구조를 채택하였다는 점을 들 수 있을 것 같고 디버깅의 편의를 위해 단방향 바인딩을 채택한 점도 눈에 띄는 지점인 것 같습니다.

3. flux 패턴에 대하여 설명해주세요.

flux 패턴은 데이터 흐름을 단방향 구조로 원활히 관리하기 위하여 만들어진 패턴이라고 정의할 수 있습니다.

flux 패턴을 구현할 때에는 통상적으로 action creator / dispatcher / store / view 로 구성되곤합니다.

action creator는 어떠한 "액션"을 정의합니다. 이러한 액션들은 각각 이벤트와 비슷하게도 생각을 할 수 있습니다.

action은 주로 store가 가지고 있을 상태를 조작하거나 변경하기 위해서 발행됩니다.

그러나 이 action은 스스로 store의 상태를 변경할 수 없습니다.

flux 패턴에서 스토어의 변경은 오로지 dispatcher를 통해서만 가능하기 떄문인데요

이렇듯 변경에 대한 책임을 디스패처에게 지우는 것을 통하여 데이터흐름은 action -> dispatch -> store의 순서로 흘러가게 됩니다.

주로 action은 사용자의 상호작용에 의하여 발생한다는 관점을 추가하여 본다면

view -> action -> dispatch -> store의 순서가 되겠지요

store와 view의 관계는 옵저버패턴과 유사한 모습을 띕니다. store는 여러가지 상태를 지니고 있으며 view는 이러한 상태들 중 자신에게 필요한 일부 상태를 "구독"할 수 있습니다. 그리고 store에서 자신이 구독하고 있는 상태가 변경되었다면 view는 이 변경된 상태를 화면에 반영해야 한다는 것을 알게되니까요

이렇듯 flux 패턴을 통하여 데이터 흐름을 관리하게 되면 데이터가 흐르는 방향이 명료해지며 상태가 단일 출처의 "스토어"에서 관리되기 때문에 모든 view는 동일한 상태를 화면에 그릴 수 있어지는 효과를 얻을 수 있습니다.

4. 상태관리에 대하여 설명해주세요.

대부분의 애플리케이션은 사용자와의 상호작용을 통해 상호작용에 따른 적절한 인터랙션을 보여주는 형태로 발전해왔습니다.

어떠한 상호작용이 발생하였을 때 어떠한 행동을 적절히 취하는 것은 물론 여러가지 요구사항들을 충족하기 위해서

애플리케이션은 점점 알아야할 정보들이 많아지게 되었습니다.

이러한 변화에 따라 관리해야하는 데이터가 늘어나게 되었으며 해당 데이터가 어떤 "상태"인지를 알아야하며

어떻게 "변경"해야 할지를 고민해야하는 시점이 오게 되었고

궁극적으로는 해당 데이터를 신뢰 할 수 있게 관리해야할 필요성이 생겨나게 되었습니다.

이러한 관점에서 애플리케이션이 복잡해지고 요구사항이 늘어남에 따라 상태 관리에 대한 수요가 생겨나게 되었으며

이러한 문제를 해결하기 위해 여러가지 방법론, 라이브러리들이 등장하게 되었습니다.

5. 궁금한 것에 대하여 알려주세요.

궁금한 점은 없습니다.
